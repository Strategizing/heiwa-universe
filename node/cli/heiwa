#!/Users/dmcgregsauce/heiwa/.venv/bin/python3
import argparse
import os
import json
import uuid
import subprocess
import sys
import shlex
from pathlib import Path

HEIWA_GLOBAL_DIR = Path(os.path.expanduser("~/.heiwa"))
IDENTITY_FILE = HEIWA_GLOBAL_DIR / "identity.json"
MONOREPO_ROOT = Path(__file__).resolve().parents[2]
NODE_ROOT = MONOREPO_ROOT / "node"
RUNTIME_ROOT = MONOREPO_ROOT / "runtime"


def _resolve_python() -> str:
    candidates = [
        MONOREPO_ROOT / ".venv313/bin/python",
        MONOREPO_ROOT / ".venv/bin/python",
    ]
    for candidate in candidates:
        if candidate.exists():
            return str(candidate)
    return sys.executable

def init_global_dir():
    HEIWA_GLOBAL_DIR.mkdir(parents=True, exist_ok=True)
    (HEIWA_GLOBAL_DIR / "workspace").mkdir(exist_ok=True)
    (HEIWA_GLOBAL_DIR / "context").mkdir(exist_ok=True)

def cmd_login(args):
    """Authenticate and provision the local node identity."""
    init_global_dir()
    
    # Auto-detection: If already logged in and no name provided, use existing
    if IDENTITY_FILE.exists() and not args.force and not args.name:
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        login_target = identity.get('name', 'devon')
        print(f"üîÑ Auto-detected registered node: {login_target}")
    else:
        # Handle specific login targets (devon/macbook-node/workstation-node)
        login_target = args.name if args.name else "devon"

    is_devon = login_target.lower() == "devon"
    
    # Standard check for existing non-devon nodes to prevent accidental duplicate IDs
    if IDENTITY_FILE.exists() and not args.force and not args.name == login_target:
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        if not is_devon and identity.get('name') == login_target:
            print(f"‚úÖ Already logged in as: {identity.get('name')} ({identity.get('role')})")
            return

    # Ultimate access provisioning for 'devon'
    role = "admin" if is_devon else "heiwa-node"
    capabilities = ["compute", "orchestration", "browser", "ultimate_access"] if is_devon else ["compute", "orchestration"]
    
    # Only generate new identity if forcing or target changed
    if not IDENTITY_FILE.exists() or args.force or (args.name and args.name != login_target):
        identity = {
            "uuid": str(uuid.uuid4()),
            "name": login_target,
            "role": role,
            "capabilities": capabilities
        }
        with open(IDENTITY_FILE, "w") as f:
            json.dump(identity, f, indent=4)
        
        if is_devon:
            print(f"üëë **Ultimate Access Established** for {login_target}.")
        else:
            print(f"üöÄ Node initialized as: {login_target}")
    else:
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        print(f"üëã Welcome back, {login_target}.")

    # Launch Terminal Chat
    python_bin = _resolve_python()
    chat_script = NODE_ROOT / "cli/scripts/terminal_chat.py"
    
    cmd = [python_bin, str(chat_script), login_target, os.uname()[1]]
    subprocess.run(cmd)

def _run_subprocess(cmd):
    """Helper to run a shell command and stream output."""
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def cmd_up(args):
    """Start the local environment."""
    print("üöÄ [HEIWA] Starting local Orchestrator environment...")

    python_bin = _resolve_python()
    cmd = (
        f"cd {shlex.quote(str(MONOREPO_ROOT))} && "
        f"PYTHONPATH={shlex.quote(str(RUNTIME_ROOT))} "
        f"{shlex.quote(python_bin)} -m fleets.hub.main"
    )
    _run_subprocess(cmd)

def cmd_doctor(args):
    """Run local operability checks."""
    print("ü©∫ [HEIWA] Running diagnostics...")
    python_bin = _resolve_python()
    doctor_script = NODE_ROOT / "cli/scripts/doctor.py"
    cmd = (
        f"cd {shlex.quote(str(MONOREPO_ROOT))} && "
        f"{shlex.quote(python_bin)} {shlex.quote(str(doctor_script))}"
    )
    _run_subprocess(cmd)

def cmd_cutover(args):
    """Run the automated domain cutover sequence."""
    print("‚ú® [HEIWA] Initiating automated domain cutover...")
    python_bin = _resolve_python()
    cutover_script = NODE_ROOT / "cli/scripts/ops/cutover_domains.py"
    if cutover_script.exists():
        cmd = [python_bin, str(cutover_script)]
        subprocess.run(cmd)
    else:
        print("‚ùå Cutover script not found.")

def cmd_domains(args):
    """Run domain resolution and health probes."""
    print("üåç [HEIWA] Probing domains...")
    python_bin = _resolve_python()
    probe_script = NODE_ROOT / "cli/scripts/ops/probe_domains.py"
    if probe_script.exists():
        cmd = [python_bin, str(probe_script)]
        subprocess.run(cmd)
    else:
        print("‚ùå Probe script not found.")

def cmd_provision(args):
    """Prepare a provisioning environment for a new node."""
    print(f"üèóÔ∏è [HEIWA] Provisioning node: {args.node_id}...")
    python_bin = _resolve_python()
    provision_script = NODE_ROOT / "cli/scripts/ops/provision_node.sh"
    if provision_script.exists():
        cmd = ["bash", str(provision_script), args.node_id, args.node_type]
        subprocess.run(cmd)
    else:
        print("‚ùå Provision script not found.")

def cmd_deploy(args):
    """Deploy Infrastructure and Compute."""
    print("üöÄ [HEIWA] Initiating Deployment Sequence...")
    
    if args.edge or args.full:
        print("\nüõ°Ô∏è Deploying Edge Configuration (Cloudflare WAF/DNS)...")
        terraform_dir = MONOREPO_ROOT / "infrastructure" / "terraform" / "cloudflare"
        if (terraform_dir / "main.tf").exists():
            print("   Running Terraform apply...")
            # We assume token is exported or in environment
            cmd = f"cd {shlex.quote(str(terraform_dir))} && terraform apply -auto-approve"
            _run_subprocess(cmd)
        else:
            print("   ‚ùå Terraform configs not found.")

    if args.compute or args.full or not (args.edge or args.compute or args.full):
        # Default behavior is compute if no flags passed
        print("\n‚òÅÔ∏è Deploying Compute to Cloud HQ (Railway)...")
        service = os.getenv("HEIWA_RAILWAY_SERVICE", "heiwa-cloud-hq")
        _run_subprocess(f"railway up --service {shlex.quote(service)} --detach")

def cmd_identity(args):
    """Select a pre-programmed Heiwa identity from conversation intent."""
    python_bin = _resolve_python()
    selector = NODE_ROOT / "cli/scripts/ops/identity_selector.py"
    if not selector.exists():
        print("‚ùå Identity selector script not found.")
        sys.exit(1)

    cmd = [python_bin, str(selector), "--text", args.text]
    if args.json:
        cmd.append("--json")
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def main():
    parser = argparse.ArgumentParser(description="Heiwa Enterprise CLI")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # login
    parser_login = subparsers.add_parser("login", help="Authenticate and provision node identity")
    parser_login.add_argument("name", nargs="?", help="Human or Machine name for the identity")
    parser_login.add_argument("--force", action="store_true", help="Overwrite existing identity")

    # up
    parser_up = subparsers.add_parser("up", help="Start the local Heiwa instance")

    # doctor
    parser_doctor = subparsers.add_parser("doctor", help="Run operability and dependency checks")

    # deploy
    parser_deploy = subparsers.add_parser("deploy", help="Push the current matrix to Railway or Cloudflare")
    parser_deploy.add_argument("--edge", action="store_true", help="Deploy only edge WAF/DNS (Cloudflare)")
    parser_deploy.add_argument("--compute", action="store_true", help="Deploy only compute node (Railway)")
    parser_deploy.add_argument("--full", action="store_true", help="Deploy both edge and compute")

    # domains
    parser_domains = subparsers.add_parser("domains", help="Probe domain resolution and status")

    # cutover
    parser_cutover = subparsers.add_parser("run-cutover", help="Run automated domain cutover sequence")

    # provision
    parser_provision = subparsers.add_parser("provision-node", help="Prepare environment for a new swarm node")
    parser_provision.add_argument("node_id", help="Unique ID for the node (e.g. workstation)")
    parser_provision.add_argument("--node-type", default="heavy_compute", help="Type of hardware (mobile_node|heavy_compute)")

    # identity
    parser_identity = subparsers.add_parser(
        "identity",
        help="Resolve pre-programmed identity from conversation intent",
    )
    parser_identity.add_argument("text", help="Conversation/task text used for identity selection")
    parser_identity.add_argument("--json", action="store_true", help="Emit JSON output")

    # update
    parser_update = subparsers.add_parser("update", help="Auto-patch and update the Heiwa Swarm")

    # logout
    parser_logout = subparsers.add_parser("logout", help="Clear the local node identity")

    # status
    parser_status = subparsers.add_parser("status", help="Check swarm connectivity and node health")
    parser_status.add_argument("--full", action="store_true", help="Perform a swarm-wide telemetry probe")

    # research
    parser_research = subparsers.add_parser("research", help="Trigger a web research/scraping task")
    parser_research.add_argument("target", help="URL or topic to research")

    # audit
    parser_audit = subparsers.add_parser("audit", help="Run a self-improvement system audit")

    args = parser.parse_args()

    if args.command == "login":
        cmd_login(args)
    elif args.command == "up":
        cmd_up(args)
    elif args.command == "doctor":
        cmd_doctor(args)
    elif args.command == "deploy":
        cmd_deploy(args)
    elif args.command == "domains":
        cmd_domains(args)
    elif args.command == "run-cutover":
        cmd_cutover(args)
    elif args.command == "provision-node":
        cmd_provision(args)
    elif args.command == "identity":
        cmd_identity(args)
    elif args.command == "update":
        cmd_update(args)
    elif args.command == "logout":
        cmd_logout(args)
    elif args.command == "status":
        cmd_status(args)
    elif args.command == "research":
        cmd_research(args)
    elif args.command == "audit":
        cmd_audit(args)

def cmd_research(args):
    """Trigger a web research task via NATS."""
    print(f"üîç [HEIWA] Initiating research task for: {args.target}")
    # We use a simple placeholder task ID until NATS publish wiring is added.
    task_id = f"research-{uuid.uuid4().hex[:8]}"
    print(f"üì° Task {task_id} published to mesh. Results will appear in #field-intel.")

def cmd_audit(args):
    """Run a local system audit."""
    print("üõ°Ô∏è [HEIWA] Running Machine Self-Improvement Audit...")
    python_bin = _resolve_python()
    audit_script = NODE_ROOT / "cli/scripts/ops/heiwa_360_check.py"
    if audit_script.exists():
        cmd = (
            f"cd {shlex.quote(str(MONOREPO_ROOT))} && "
            f"PYTHONPATH={shlex.quote(str(RUNTIME_ROOT))} "
            f"{shlex.quote(python_bin)} {shlex.quote(str(audit_script))}"
        )
        _run_subprocess(cmd)
    else:
        print("‚ùå Audit script not found in runtime.")

def cmd_status(args):
    """Check swarm connectivity and node health."""
    print("üõ∞Ô∏è [HEIWA] Probing Swarm Status...")
    
    # 1. Check Identity
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        print(f"üë§ Identity: {identity.get('name')} ({identity.get('role')})")
    else:
        print("üë§ Identity: Not logged in.")

    # 2. Check NATS (Simple Ping)
    nats_url = os.getenv("NATS_URL", "nats://localhost:4222")
    print(f"üì° NATS Mesh: {nats_url}")
    
    # 3. Model-Centric Node Check
    print("\nüß† Active Model Instances (Local):")
    try:
        import requests
        resp = requests.get("http://localhost:11434/api/tags", timeout=2)
        if resp.status_code == 200:
            models = resp.json().get('models', [])
            for m in models:
                print(f"   - {m['name']} (Ready)")
        else:
            print("   - Ollama service unreachable")
    except:
        print("   - Ollama service unreachable")

    # 4. Local Resource Usage
    import psutil
    ram = psutil.virtual_memory().percent
    cpu = psutil.cpu_percent(interval=0.1)
    print(f"\nüìä Local Hardware Utilization:")
    print(f"   CPU: {cpu}%")
    print(f"   RAM: {ram}%")

    if args.full:
        print("\nüåê Swarm-wide Telemetry (Requesting from Mesh Brain)...")
        # Future: Add NATS request/reply logic here to fetch report from TelemetryAgent
        print("   (Feature coming in next sync: Live Mesh Report)")

def cmd_logout(args):
    """Clear the local node identity."""
    if IDENTITY_FILE.exists():
        os.remove(IDENTITY_FILE)
        print("üîí Logged out. Local identity cleared.")
    else:
        print("Already logged out.")

def cmd_update(args):
    """Trigger the auto-patcher and system update."""
    print("‚ú® [HEIWA] Initiating Swarm Self-Patching sequence...")
    # This will eventually trigger the auto_patcher script on the cloud or local node
    print(f"Checking for updates in {MONOREPO_ROOT}...")
    _run_subprocess(f"cd {shlex.quote(str(MONOREPO_ROOT))} && git pull --ff-only")
    print("‚úÖ System core updated. Running doctor to verify health...")
    cmd_doctor(args)

if __name__ == "__main__":
    main()
