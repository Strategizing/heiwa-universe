#!/usr/bin/env python3
import os
import sys
import json
import uuid
import subprocess
import shlex
import re
from pathlib import Path

# --- SOTA ROOT DISCOVERY ---
def find_monorepo_root(start_path: Path) -> Path:
    """Recursively search for the monorepo root containing 'apps' and 'packages'."""
    current = start_path.resolve()
    for _ in range(5): # Limit depth
        if (current / "apps").exists() and (current / "packages").exists():
            return current
        if current.parent == current:
            break
        current = current.parent
    # Fallback to hardcoded path if discovery fails
    return Path("/Users/dmcgregsauce/heiwa")

MONOREPO_ROOT = find_monorepo_root(Path(__file__).resolve().parent)
APPS_ROOT = MONOREPO_ROOT / "apps"
PACKAGES_ROOT = MONOREPO_ROOT / "packages"
VENV_BIN = MONOREPO_ROOT / ".venv/bin/python3"

# --- VENV ESCALATION ---
if VENV_BIN.exists() and sys.executable != str(VENV_BIN):
    # Pass necessary paths to the venv
    os.environ["PYTHONPATH"] = f"{PACKAGES_ROOT}/heiwa_sdk:{PACKAGES_ROOT}/heiwa_protocol:{PACKAGES_ROOT}/heiwa_identity:{PACKAGES_ROOT}/heiwa_ui:{APPS_ROOT}"
    os.execv(str(VENV_BIN), [str(VENV_BIN)] + sys.argv)

# --- CORE IMPORTS ---
import argparse

# Load SOTA Environment via SDK
try:
    sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_sdk"))
    from heiwa_sdk.config import load_swarm_env
    load_swarm_env()
except ImportError:
    pass

HEIWA_GLOBAL_DIR = Path(os.path.expanduser("~/.heiwa"))
IDENTITY_FILE = HEIWA_GLOBAL_DIR / "identity.json"
_CRED_URL_RE = re.compile(r"(://)[^:@/]+:[^@/]+@")


def _redact_url_credentials(url: str) -> str:
    return _CRED_URL_RE.sub(r"\1<user>:<redacted>@", url or "")

def _resolve_python() -> str:
    return sys.executable

def init_global_dir():
    HEIWA_GLOBAL_DIR.mkdir(parents=True, exist_ok=True)
    (HEIWA_GLOBAL_DIR / "workspace").mkdir(exist_ok=True)
    (HEIWA_GLOBAL_DIR / "context").mkdir(exist_ok=True)

def cmd_login(args):
    """Authenticate and provision the local node identity."""
    init_global_dir()
    login_target = args.name if args.name else "devon"
    is_devon = login_target.lower() == "devon"
    role = "admin" if is_devon else "heiwa-node"
    capabilities = ["compute", "orchestration", "browser", "ultimate_access"] if is_devon else ["compute", "orchestration"]
    
    identity = {
        "uuid": str(uuid.uuid4()),
        "name": login_target,
        "role": role,
        "capabilities": capabilities
    }
    with open(IDENTITY_FILE, "w") as f:
        json.dump(identity, f, indent=4)
    print(f"üöÄ Identity initialized: {login_target} ({role})")

def cmd_chat(args):
    """Launch the high-end interactive Terminal Chat."""
    init_global_dir()
    python_bin = _resolve_python()
    chat_script = APPS_ROOT / "heiwa_cli/scripts/terminal_chat.py"
    
    if not chat_script.exists():
        print(f"‚ùå Terminal chat script not found at {chat_script}")
        sys.exit(1)

    node_name = "macbook@heiwa-agile"
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
            node_name = identity.get("name", node_name)

    # Inject paths for imports
    os.environ["PYTHONPATH"] = f"{PACKAGES_ROOT}/heiwa_sdk:{PACKAGES_ROOT}/heiwa_protocol:{PACKAGES_ROOT}/heiwa_identity:{PACKAGES_ROOT}/heiwa_ui:{APPS_ROOT}"
    
    cmd_args = [str(python_bin), str(chat_script), node_name]
    if args.prompt:
        cmd_args.append(args.prompt)
        
    try:
        subprocess.run(cmd_args, check=True)
    except KeyboardInterrupt:
        pass
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def cmd_cost(args):
    """Show swarm-wide token usage and cost report."""
    print("üí∞ [HEIWA] Generating Swarm Cost Report...")
    sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_sdk"))
    from heiwa_sdk.db import Database
    db = Database()
    summary = db.get_model_usage_summary(minutes=1440)
    if not summary:
        print("   No usage data found for the last 24h.")
        return
    
    print(f"{'Model':<40} | {'Requests':<10} | {'Total Tokens':<12}")
    print("-" * 68)
    for row in summary:
        print(f"{row['model_id']:<40} | {row['request_count']:<10} | {row['total_tokens']:<12}")

def cmd_status(args):
    """Check swarm connectivity and node health."""
    print("üõ∞Ô∏è [HEIWA] Probing Swarm Status...")
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        print(f"üë§ Identity: {identity.get('name')} ({identity.get('role')})")
    
    nats_url = os.getenv("NATS_URL", "nats://localhost:4222")
    print(f"üì° NATS Mesh: {_redact_url_credentials(nats_url)}")
    
    print("\nüìä Local Hardware Utilization:")
    try:
        import psutil
        print(f"   CPU: {psutil.cpu_percent()}%")
        print(f"   RAM: {psutil.virtual_memory().percent}%")
    except ImportError:
        print("   psutil not installed in current environment.")

def _run_subprocess(cmd):
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def cmd_deploy(args):
    """Deploy Infrastructure and Compute."""
    print("üöÄ [HEIWA] Initiating Deployment Sequence...")
    if args.edge or args.full:
        print("\nüõ°Ô∏è Deploying Edge Configuration (Cloudflare WAF/DNS)...")
        tf_dir = MONOREPO_ROOT / "infra/cloud/cloudflare"
        if (tf_dir / "main.tf").exists():
            cmd = f"cd {shlex.quote(str(tf_dir))} && terraform apply -auto-approve"
            _run_subprocess(cmd)
    if args.compute or args.full or not (args.edge or args.compute or args.full):
        print("\n‚òÅÔ∏è Deploying Compute to Cloud HQ (Railway)...")
        # Ensure RAILWAY_TOKEN is present
        if not os.getenv("RAILWAY_TOKEN"):
            print("‚ö†Ô∏è  RAILWAY_TOKEN not found in environment. Deployment might fail.")
        _run_subprocess(f"railway up --detach")

def main():
    parser = argparse.ArgumentParser(description=f"Heiwa Enterprise CLI")
    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    parser_chat = subparsers.add_parser("chat", help="Launch interactive swarm chat (Default)")
    parser_chat.add_argument("prompt", nargs="?", help="Optional prompt to dispatch immediately")
    
    parser_login = subparsers.add_parser("login", help="Authenticate and provision node identity")
    parser_login.add_argument("name", nargs="?", help="Identity name")
    
    subparsers.add_parser("status", help="Check swarm connectivity and node health")
    
    parser_deploy = subparsers.add_parser("deploy", help="Push the current matrix to Railway or Cloudflare")
    parser_deploy.add_argument("--edge", action="store_true")
    parser_deploy.add_argument("--compute", action="store_true")
    parser_deploy.add_argument("--full", action="store_true")

    subparsers.add_parser("cost", help="Show swarm-wide token usage")

    if len(sys.argv) > 1 and sys.argv[1] not in subparsers.choices and not sys.argv[1].startswith("-"):
        sys.argv.insert(1, "chat")
    elif len(sys.argv) == 1:
        sys.argv.append("chat")

    args = parser.parse_args()

    if args.command == "chat":
        cmd_chat(args)
    elif args.command == "login":
        cmd_login(args)
    elif args.command == "deploy":
        cmd_deploy(args)
    elif args.command == "cost":
        cmd_cost(args)
    elif args.command == "status":
        cmd_status(args)

if __name__ == "__main__":
    main()
