#!/usr/bin/env python3
import os
import sys
import json
import uuid
import subprocess
import shlex
import re
from pathlib import Path

# --- SOTA ROOT DISCOVERY ---
def find_monorepo_root(start_path: Path) -> Path:
    """Recursively search for the monorepo root containing 'apps' and 'packages'."""
    current = start_path.resolve()
    for _ in range(5): # Limit depth
        if (current / "apps").exists() and (current / "packages").exists():
            return current
        if current.parent == current:
            break
        current = current.parent
    # Fallback to hardcoded path if discovery fails
    return Path("/Users/dmcgregsauce/heiwa")

MONOREPO_ROOT = find_monorepo_root(Path(__file__).resolve().parent)
APPS_ROOT = MONOREPO_ROOT / "apps"
PACKAGES_ROOT = MONOREPO_ROOT / "packages"
VENV_BIN = MONOREPO_ROOT / ".venv/bin/python3"

# --- PATH SETUP ---
# Ensure local packages are discoverable regardless of how the script is invoked
sys.path.insert(0, str(APPS_ROOT))
sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_sdk"))
sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_protocol"))
sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_identity"))
sys.path.insert(0, str(PACKAGES_ROOT / "heiwa_ui"))

# --- VENV ESCALATION ---
if VENV_BIN.exists() and sys.executable != str(VENV_BIN):
    # Pass necessary paths to the venv
    os.environ["PYTHONPATH"] = ":".join([
        str(PACKAGES_ROOT / "heiwa_sdk"),
        str(PACKAGES_ROOT / "heiwa_protocol"),
        str(PACKAGES_ROOT / "heiwa_identity"),
        str(PACKAGES_ROOT / "heiwa_ui"),
        str(APPS_ROOT)
    ])
    os.execv(str(VENV_BIN), [str(VENV_BIN)] + sys.argv)

# --- CORE IMPORTS ---
import argparse
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    from rich import box
    from rich.text import Text
    from rich.columns import Columns
    from rich.markdown import Markdown
    from rich.theme import Theme
    HAS_RICH = True
except ImportError:
    HAS_RICH = False

from heiwa_sdk.tool_mesh import ToolMesh
from heiwa_sdk.routing import ModelRouter
from heiwa_sdk.db import Database
from heiwa_sdk.config import load_swarm_env, settings

# Load environment early
load_swarm_env()

# Custom Theme
HEIWA_THEME = Theme({
    "info": "cyan",
    "warning": "yellow",
    "error": "bold red",
    "success": "bold green",
    "brand": "bold blue",
    "dim": "dim white"
})

console = Console(theme=HEIWA_THEME)

# --- HEIWA BRANDING ---
BANNER = """
    ‚ñà‚ñë‚ñà‚ÄÉ‚ñà‚ñÄ‚ñÄ‚ÄÉ‚ñà‚ÄÉ‚ñà‚ñë‚ñà‚ñë‚ñà‚ÄÉ‚ñÑ‚ñÄ‚ñà
    ‚ñà‚ñÄ‚ñà‚ÄÉ‚ñà‚ñà‚ñÑ‚ÄÉ‚ñà‚ÄÉ‚ñÄ‚ñÑ‚ñÄ‚ñÑ‚ñÄ‚ÄÉ‚ñà‚ñÄ‚ñà 
"""

def print_banner():
    if not HAS_RICH:
        print(BANNER)
        print(" [ HEIWA ENTERPRISE HUB v2.1 ] ")
        return
    
    console.print(Text(BANNER, style="brand"))
    console.print(Panel(
        Text("HEIWA ENTERPRISE CONTROL PLANE v2.1", justify="center", style="bold white"),
        box=box.DOUBLE,
        border_style="brand"
    ))

# --- PERSISTENT RUNTIME ---
class HeiwaRuntime:
    def __init__(self):
        self.root = MONOREPO_ROOT
        self.db = Database()
        self.mesh = ToolMesh(self.root)
        self.router = ModelRouter()
        self.session_id = str(uuid.uuid4())[:8]

HEIWA_GLOBAL_DIR = Path(os.path.expanduser("~/.heiwa"))
IDENTITY_FILE = HEIWA_GLOBAL_DIR / "identity.json"

def _redact_url_credentials(url: str) -> str:
    return re.sub(r"(://)[^:@/]+:[^@/]+@", r"\1<user>:<redacted>@", url or "")

def init_global_dir():
    HEIWA_GLOBAL_DIR.mkdir(parents=True, exist_ok=True)
    (HEIWA_GLOBAL_DIR / "workspace").mkdir(exist_ok=True)
    (HEIWA_GLOBAL_DIR / "context").mkdir(exist_ok=True)

# --- COMMANDS ---
def cmd_login(args):
    """Authenticate and provision the local node identity."""
    print_banner()
    init_global_dir()
    login_target = args.name if args.name else "devon"
    is_devon = login_target.lower() == "devon"
    role = "admin" if is_devon else "heiwa-node"
    capabilities = ["compute", "orchestration", "browser", "ultimate_access"] if is_devon else ["compute", "orchestration"]
    
    identity = {
        "uuid": str(uuid.uuid4()),
        "name": login_target,
        "role": role,
        "capabilities": capabilities
    }
    with open(IDENTITY_FILE, "w") as f:
        json.dump(identity, f, indent=4)
    
    console.print(f"[success]üöÄ Identity initialized:[/success] {login_target} ({role})")

def cmd_status(args):
    """Check swarm connectivity and node health."""
    print_banner()
    
    import time
    from rich.table import Table
    from rich.panel import Panel

    table = Table(box=box.SIMPLE, show_header=False, border_style="dim")
    
    # Identity
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
        table.add_row("[brand]Identity[/brand]", f"{identity.get('name')} ([dim]{identity.get('role')}[/dim])")
    
    # NATS
    nats_url = settings.NATS_URL or "nats://localhost:4222"
    table.add_row("[brand]NATS Mesh[/brand]", _redact_url_credentials(nats_url))
    
    # Local HW
    try:
        import psutil
        cpu = psutil.cpu_percent()
        ram = psutil.virtual_memory().percent
        table.add_row("[brand]CPU[/brand]", f"{cpu}%")
        table.add_row("[brand]RAM[/brand]", f"{ram}%")
    except ImportError:
        pass

    console.print(Panel(table, title="[bold white]Systems Overlay[/bold white]", border_style="brand"))

    # Active Swarm Nodes
    db = Database()
    nodes = db.list_nodes(status="ONLINE")
    if nodes:
        node_table = Table(title=" Swarm Fleet Topology ", box=box.ROUNDED, header_style="bold cyan", border_style="brand")
        node_table.add_column("Node ID", style="cyan")
        node_table.add_column("Role")
        node_table.add_column("CPU")
        node_table.add_column("RAM")
        node_table.add_column("Last Pulse")
        
        for node in nodes:
            # Check if last_heartbeat_at is recently
            last_hb_str = node.get('last_heartbeat_at')
            if last_hb_str:
                try:
                    import datetime
                    last_hb = datetime.datetime.fromisoformat(last_hb_str)
                    now = datetime.datetime.now(datetime.timezone.utc)
                    diff = (now - last_hb).total_seconds()
                    pulse_str = f"{int(diff)}s ago" if diff < 3600 else ">1h ago"
                except:
                    pulse_str = "Unknown"
            else:
                pulse_str = "Never"

            meta = json.loads(node.get('meta_json', '{}'))
            node_table.add_row(
                node['node_id'],
                node.get('role', 'worker'),
                f"{meta.get('cpu_pct', '0')}%",
                f"{meta.get('ram_pct', '0')}%",
                pulse_str
            )
        console.print(node_table)
    else:
        console.print("[dim]No other active nodes detected in swarm.[/dim]")

def cmd_dispatch(args):
    """One-shot task dispatch to the swarm."""
    if not args.prompt:
        # If no prompt, print help for dispatch or enter interactive mode
        print_banner()
        console.print("[warning]Missing prompt.[/warning] Usage: [bold]heiwa <prompt>[/bold] or [bold]heiwa dispatch <prompt>[/bold]")
        return

    init_global_dir()
    python_bin = sys.executable
    dispatch_script = APPS_ROOT / "heiwa_cli/scripts/dispatch_once.py"
    handshake_script = APPS_ROOT / "heiwa_cli/scripts/handshake.py"
    
    node_name = "macbook@heiwa-agile"
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
            node_name = identity.get("name", node_name)

    # Block dispatch if handshake is red
    hs_res = subprocess.run([str(python_bin), str(handshake_script), "--quiet"], capture_output=True)
    if hs_res.returncode != 0:
        console.print("[error]‚ùå [BLOCKED] Dispatch aborted because swarm handshake failed.[/error]")
        console.print("üí° Run [brand]heiwa handshake[/brand] to diagnose connectivity or auth issues.")
        sys.exit(1)

    cmd_args = [str(python_bin), str(dispatch_script), node_name, args.prompt]
    try:
        subprocess.run(cmd_args, check=True)
    except KeyboardInterrupt:
        pass
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def cmd_chat(args):
    """Launch the high-end interactive Terminal Chat."""
    init_global_dir()
    chat_script = APPS_ROOT / "heiwa_cli/scripts/terminal_chat.py"
    
    node_name = "macbook@heiwa-agile"
    if IDENTITY_FILE.exists():
        with open(IDENTITY_FILE, "r") as f:
            identity = json.load(f)
            node_name = identity.get("name", node_name)

    cmd_args = [sys.executable, str(chat_script), node_name]
    if args.prompt: cmd_args.append(args.prompt)
        
    try:
        subprocess.run(cmd_args, check=True)
    except KeyboardInterrupt: pass
    except subprocess.CalledProcessError as e: sys.exit(e.returncode)

def cmd_cost(args):
    """Show swarm-wide token usage and cost report."""
    print_banner()
    db = Database()
    summary = db.get_model_usage_summary(minutes=1440)
    
    if not summary:
        console.print("[dim]   No usage data found for the last 24h.[/dim]")
        return
    
    table = Table(title="Swarm-Wide Token Ledger", box=box.ROUNDED, header_style="bold brand")
    table.add_column("Model", style="cyan")
    table.add_column("Requests", justify="right")
    table.add_column("Total Tokens", justify="right")
    
    for row in summary:
        table.add_row(row['model_id'], str(row['request_count']), str(row['total_tokens']))
    
    console.print(table)

def cmd_deploy(args):
    """Deploy Infrastructure and Compute."""
    print_banner()
    console.print("[brand]üöÄ Initiating Global Deployment Sequence...[/brand]")
    
    if args.edge or args.full:
        console.print("\n[bold white]üõ°Ô∏è Deploying Edge Configuration (Cloudflare)[/bold white]")
        tf_dir = MONOREPO_ROOT / "infra/cloud/cloudflare"
        if (tf_dir / "main.tf").exists():
            subprocess.run(f"cd {shlex.quote(str(tf_dir))} && terraform apply -auto-approve", shell=True)
            
    if args.compute or args.full or not (args.edge or args.compute or args.full):
        console.print("\n[bold white]‚òÅÔ∏è Deploying Compute to Cloud HQ (Railway)[/bold white]")
        subprocess.run(f"railway up --detach", shell=True)

async def cmd_buff(args):
    """Natively improve Heiwa using Heiwa."""
    print_banner()
    console.print("[success]ü¶æ Initiating Native Self-Improvement Sequence...[/success]")
    prompt = args.instruction if args.instruction else "Self-Audit: Find 3 optimizations in the SDK and implement them."
    console.print(f"üß† Reasoning about optimization: [info]{prompt}[/info]")
    # Simulation for now
    await asyncio.sleep(1)
    console.print("‚úÖ [brand]Buff sequence completed.[/brand] (Optimizations staged/applied)")

def cmd_handshake(args):
    """Validate full vertical NATS path and Auth barrier."""
    print_banner()
    handshake_script = APPS_ROOT / "heiwa_cli/scripts/handshake.py"
    subprocess.run([sys.executable, str(handshake_script)])

def main():
    parser = argparse.ArgumentParser(
        description="Heiwa Enterprise CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Use 'heiwa <prompt>' for immediate swarm dispatch."
    )
    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    # Command: chat
    subparsers.add_parser("chat", help="Launch interactive swarm chat (TUI)")
    
    # Command: dispatch
    parser_dispatch = subparsers.add_parser("dispatch", help="One-shot task dispatch")
    parser_dispatch.add_argument("prompt", nargs="?", help="Prompt to dispatch")
    
    # Command: handshake
    subparsers.add_parser("handshake", help="Validate full vertical NATS path and Auth barrier")
    
    # Command: login
    parser_login = subparsers.add_parser("login", help="Authenticate and provision node identity")
    parser_login.add_argument("name", nargs="?", help="Identity name")
    
    # Command: status
    subparsers.add_parser("status", help="Check swarm connectivity and node health")
    
    # Command: deploy
    parser_deploy = subparsers.add_parser("deploy", help="Push current matrix to Railway/Cloudflare")
    parser_deploy.add_argument("--edge", action="store_true")
    parser_deploy.add_argument("--compute", action="store_true")
    parser_deploy.add_argument("--full", action="store_true")

    # Command: cost
    subparsers.add_parser("cost", help="Show swarm-wide token usage")
    
    # Command: buff
    parser_buff = subparsers.add_parser("buff", help="Natively improve Heiwa using Heiwa")
    parser_buff.add_argument("instruction", nargs="?", help="Specific improvement directive")

    # Handle "shortcut" dispatch
    if len(sys.argv) > 1 and sys.argv[1] not in subparsers.choices and not sys.argv[1].startswith("-"):
        # Not a command, not a flag -> must be a prompt
        sys.argv.insert(1, "dispatch")
    elif len(sys.argv) == 1:
        # No args -> Launch interactive chat by default for an enterprise experience
        cmd_chat(argparse.Namespace(prompt=None))
        sys.exit(0)

    args = parser.parse_args()

    if args.command == "chat":
        cmd_chat(args)
    elif args.command == "dispatch":
        cmd_dispatch(args)
    elif args.command == "handshake":
        cmd_handshake(args)
    elif args.command == "login":
        cmd_login(args)
    elif args.command == "deploy":
        cmd_deploy(args)
    elif args.command == "cost":
        cmd_cost(args)
    elif args.command == "status":
        cmd_status(args)
    elif args.command == "buff":
        import asyncio
        asyncio.run(cmd_buff(args))
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
